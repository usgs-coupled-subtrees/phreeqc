diff -u -b /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/basicsubs.c ./basicsubs.c
--- /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/basicsubs.c	2011-02-17 01:57:02.000000000 +0100
+++ ./basicsubs.c	2011-11-10 17:40:58.000000000 +0100
@@ -322,10 +322,10 @@
 	int i;
 	LDBLE lk;
 	struct logk *logk_ptr;
-	LDBLE l_logk[8];
+   LDBLE l_logk[MAX_LOG_K_INDICES];
 	struct name_coef add_logk;
 
-	for (i = 0; i < 8; i++)
+   for (i = 0; i < MAX_LOG_K_INDICES; i++)
 	{
 		l_logk[i] = 0.0;
 	}
@@ -336,7 +336,7 @@
 		add_logk.name = token;
 		add_logk.coef = 1.0;
 		add_other_logk(l_logk, 1, &add_logk);
-		lk = k_calc(l_logk, tk_x);
+      lk = k_calc(l_logk, tk_x, patm_x * PASCAL_PER_ATM);
 		return (lk);
 	}
 	return (-999.99);
@@ -351,19 +351,19 @@
 	char token[MAX_LENGTH];
 	struct phase *phase_ptr;
 	LDBLE lk;
-	LDBLE l_logk[8];
+   LDBLE l_logk[MAX_LOG_K_INDICES];
 
 	strcpy(token, name);
 	phase_ptr = phase_bsearch(token, &j, FALSE);
 	if (phase_ptr != NULL)
 	{
-		for (i = 0; i < 8; i++)
+      for (i = 0; i < MAX_LOG_K_INDICES; i++)
 		{
 			l_logk[i] = 0.0;
 		}
 		select_log_k_expression(phase_ptr->logk, l_logk);
 		add_other_logk(l_logk, phase_ptr->count_add_logk, phase_ptr->add_logk);
-		lk = k_calc(l_logk, tk_x);
+      lk = k_calc(l_logk, tk_x, patm_x * PASCAL_PER_ATM);
 		return (lk);
 	}
 	return (-999.99);
@@ -377,19 +377,19 @@
 	int i;
 	char token[MAX_LENGTH];
 	struct species *s_ptr;
-	LDBLE lk, l_logk[8];
+   LDBLE lk, l_logk[MAX_LOG_K_INDICES];
 
 	strcpy(token, name);
 	s_ptr = s_search(token);
 	if (s_ptr != NULL)
 	{
-		for (i = 0; i < 8; i++)
+      for (i = 0; i < MAX_LOG_K_INDICES; i++)
 		{
 			l_logk[i] = 0.0;
 		}
 		select_log_k_expression(s_ptr->logk, l_logk);
 		add_other_logk(l_logk, s_ptr->count_add_logk, s_ptr->add_logk);
-		lk = k_calc(l_logk, tk_x);
+      lk = k_calc(l_logk, tk_x, patm_x * PASCAL_PER_ATM);
 		return (lk);
 	}
 	return (-999.99);
diff -u -b /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/global.h ./global.h
--- /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/global.h	2011-03-23 00:26:17.000000000 +0100
+++ ./global.h	2011-11-10 17:40:58.000000000 +0100
@@ -54,7 +54,7 @@
 EXTERNAL struct model last_model;
 EXTERNAL int same_model;
 EXTERNAL int same_temperature;
-
+EXTERNAL int same_pressure;
 
 EXTERNAL struct punch punch;
 /* ----------------------------------------------------------------------
@@ -261,6 +261,7 @@
 EXTERNAL char *description_x;
 EXTERNAL LDBLE tc_x;
 EXTERNAL LDBLE tk_x;
+EXTERNAL LDBLE patm_x;
 EXTERNAL LDBLE ph_x;
 EXTERNAL LDBLE solution_pe_x;
 EXTERNAL LDBLE mu_x;
diff -u -b /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/global_structures.h ./global_structures.h
--- /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/global_structures.h	2010-06-17 22:17:08.000000000 +0200
+++ ./global_structures.h	2011-11-10 17:40:58.000000000 +0100
@@ -3,6 +3,7 @@
 
 #include "phrqtype.h"
 typedef enum { kcal, cal, kjoules, joules } DELTA_H_UNIT;
+typedef enum { cm3_per_mol } DELTA_V_UNIT;
 enum SURFACE_TYPE
 { UNKNOWN_DL, NO_EDL, DDL, CD_MUSIC, CCM };
 enum DIFFUSE_LAYER_TYPE
@@ -22,7 +23,18 @@
 #define NA (float) -9.9999	            /* NA = not available */
 /* search.h -- declarations for POSIX/SVID-compatible search functions */
 
-
+typedef enum {
+  logK_T0,
+  delta_h,
+  T_A1,
+  T_A2,
+  T_A3,
+  T_A4,
+  T_A5,
+  T_A6,
+  delta_v,     /* molar volume */
+  MAX_LOG_K_INDICES   /* Keep this definition at the end of the enum */
+} LOG_K_INDICES;
 
 /* ----------------------------------------------------------------------
  *   DEFINITIONS
@@ -36,9 +48,9 @@
 #define EPSILON 78.5			/* dialectric constant, dimensionless */
 #define EPSILON_ZERO 8.854e-12	/* permittivity of free space, C/V-m = C**2/m-J */
 #define JOULES_PER_CALORIE 4.1840
+#define PASCAL_PER_ATM 1.01325E5 /* conversion from atm to Pa */
 #define AVOGADRO 6.02252e23		/* atoms / mole */
 
-
 #define TRUE 1
 #define FALSE 0
 #define OK 1
@@ -149,7 +161,7 @@
 #define MIN_TOTAL_SS MIN_TOTAL
 #define MIN_RELATED_SURFACE MIN_TOTAL*100
 #define MIN_RELATED_LOG_ACTIVITY -30
-
+#define REF_PRES_PASCAL 1.01325E5   /* Reference pressure: 1 atm */
 
 /*
  *   Hash definitions
@@ -248,6 +260,8 @@
 	char **surface_comp;
 	int count_surface_charge;
 	char **surface_charge;
+
+   LDBLE pressure;
 };
 
 struct name_master
@@ -862,6 +876,7 @@
  	struct isotope *isotopes;
  	struct master_activity *species_gamma;
  	int count_species_gamma;
+    LDBLE patm;
  };
  struct master_activity
  {
@@ -966,7 +981,7 @@
  *---------------------------------------------------------------------- */
 struct reaction
 {
-	LDBLE logk[8];
+   LDBLE logk[MAX_LOG_K_INDICES];
 	LDBLE dz[3];
 	struct rxn_token *token;
 };
@@ -999,7 +1014,7 @@
 	LDBLE o;					/* stoichiometric coefficient of O in species */
 	LDBLE dha, dhb, a_f;		/* WATEQ Debye Huckel a and b-dot; active_fraction coef for exchange species */
 	LDBLE lk;					/* log10 k at working temperature */
-	LDBLE logk[8];				/* log kt0, delh, 6 coefficients analalytical expression */
+   LDBLE logk[MAX_LOG_K_INDICES];            /* log kt0, delh, 6 coefficients analalytical expression */
 /* VP: Density Start */
 	LDBLE millero[6];		    /* regression coefficients to calculate temperature dependent phi_0 and b_v of Millero density model */
 /* VP: Density End */
@@ -1030,17 +1045,20 @@
 											   surface */
 	LDBLE cd_music[5];
 	LDBLE dz[3];
+
+   DELTA_V_UNIT original_deltav_units;
 };
 struct logk
 {								/* Named log K's */
 	char *name;					/* name of species */
 	LDBLE lk;					/* log10 k at working temperature */
-	LDBLE log_k[8];				/* log kt0, delh, 6 coefficients analalytical expression */
+   LDBLE log_k[MAX_LOG_K_INDICES];            /* log kt0, delh, 6 coefficients analalytical expression, delta_v */
 	DELTA_H_UNIT original_units;	/* enum with original delta H units */
 	int count_add_logk;
 	int done;
 	struct name_coef *add_logk;
-	LDBLE log_k_original[8];	/* log kt0, delh, 5 coefficients analalytical expression */
+   LDBLE log_k_original[MAX_LOG_K_INDICES];   /* log kt0, delh, 6 coefficients analalytical expression, delta_v */
+   DELTA_V_UNIT original_deltav_units;
 };
 struct species_diff_layer
 {
@@ -1062,8 +1080,9 @@
 	char *formula;				/* chemical formula */
 	int in;						/* species used in model if TRUE */
 	LDBLE lk;					/* log10 k at working temperature */
-	LDBLE logk[8];				/* log kt0, delh, 6 coefficients analalytical expression */
+   LDBLE logk[MAX_LOG_K_INDICES];            /* log kt0, delh, 6 coefficients analalytical expression */
 	DELTA_H_UNIT original_units;	/* enum with original delta H units */
+   DELTA_V_UNIT original_deltav_units;
 	int count_add_logk;
 	struct name_coef *add_logk;
 	LDBLE moles_x;
@@ -1160,7 +1179,7 @@
  *---------------------------------------------------------------------- */
 struct reaction_temp
 {
-	LDBLE logk[8];
+   LDBLE logk[MAX_LOG_K_INDICES];
 	LDBLE dz[3];
 	struct rxn_token_temp *token;
 };
@@ -1254,6 +1273,7 @@
 	LDBLE water;
 	int count_iso;
 	struct iso *iso;
+   LDBLE pressure;	/* pressure in atm */
 };
 struct spread_sheet
 {
diff -u -b /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/kinetics.c ./kinetics.c
--- /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/kinetics.c	2011-03-31 19:15:59.000000000 +0200
+++ ./kinetics.c	2011-11-10 17:40:58.000000000 +0100
@@ -7,7 +7,7 @@
 #include "phqalloc.h"
 #include "output.h"
 #include "phrqproto.h"
-//#include "time.h"
+/* #include "time.h" */
 #include <time.h>
 #ifdef PHREEQC_CPP
 #include "../StorageBin.h"
@@ -1640,6 +1640,26 @@
 		{
 			use.surface_ptr = surface_bsearch(-1, &n2);
 		}
+
+/*
+ *  Adjust the total pressure to the gas pressure
+ */
+      if (use.gas_phase_ptr != NULL)
+      {
+         if (use.gas_phase_ptr->type == PRESSURE) 
+         {
+            /*
+             * Fixed-pressure Gas phase and solution will react 
+             * Change total pressure of current simulation to pressure 
+             * of gas phase
+             */
+            patm_x = use.gas_phase_ptr->total_p;
+         }
+         /*  fixed volume gas phase is handled in calc_gas_pressures */
+
+      }
+ 
+
 	}
 	/* end new */
 #ifdef SKIP
@@ -1660,9 +1680,9 @@
 	{
 		prep();
 #ifdef SKIP
-		k_temp(solution[n]->tc);
+      k_temp(solution[n]->tc, solution[n]->patm);
 #endif
-		k_temp(use.solution_ptr->tc);
+      k_temp(use.solution_ptr->tc, use.solution_ptr->patm);
 		set(FALSE);
 		converge = model();
 	}
diff -u -b /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/mainsubs.c ./mainsubs.c
--- /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/mainsubs.c	2011-03-24 17:28:16.000000000 +0100
+++ ./mainsubs.c	2011-11-10 17:40:58.000000000 +0100
@@ -400,6 +400,7 @@
  */
 	last_model.force_prep = TRUE;
 	last_model.temperature = -100;
+   last_model.pressure = 0;
 	last_model.count_exchange = -1;
 	last_model.exchange = NULL;
 	last_model.count_kinetics = -1;
@@ -689,6 +690,7 @@
 
 	same_model = FALSE;
 	same_temperature = FALSE;
+   same_pressure = FALSE;
 	g_iterations = -1;
 	G_TOL = 1e-8;
     save_init(-1);
@@ -777,7 +779,7 @@
 	surface_unknown = NULL;
 	gas_unknown = NULL;
 	s_s_unknown = NULL;
-	for (i = 0; i < 8; i++)
+   for (i = 0; i < MAX_LOG_K_INDICES; i++)
 	{
 		trxn.logk[i] = 0;
 	}
@@ -832,6 +834,7 @@
 	solution_mass = 0;
 	solution_volume = 0;
 
+   patm_x = 1;   /* Initialize pressure of component x to 1 atm */
 
 	/* model_min_value = 0; */
 
@@ -1105,7 +1108,7 @@
 			}
 			use.solution_ptr = solution[n];
 			prep();
-			k_temp(solution[n]->tc);
+         k_temp(solution[n]->tc, solution[n]->patm);
 			set(TRUE);
 			always_full_pitzer = FALSE;
 			converge = model();
@@ -1219,7 +1222,7 @@
 			}
 #endif
 			prep();
-			k_temp(use.solution_ptr->tc);
+         k_temp(use.solution_ptr->tc, use.solution_ptr->patm);
 			set(TRUE);
 			converge = model();
 			converge1 = check_residuals();
@@ -1287,10 +1290,33 @@
 						gas_phase[n].n_user, gas_phase[n].description);
 				dup_print(token, FALSE);
 			}
+
+         /* Try to obtain a solution pointer */ 
 			use.solution_ptr =
 				solution_bsearch(gas_phase[n].n_solution, &i, TRUE);
+         
+         if (use.solution_ptr != NULL)
+         {
+            /*
+             * Gas phase should be equilibrated with solution; change pressure 
+             * of initial gas phase to pressure of the solution
+             */
+            gas_phase[n].total_p = use.solution_ptr->patm;
+
+            if (print == TRUE)
+            {
+               sprintf(token, 
+                  "Gas phase %d defined to be in equilibrium with solution %d, %s (%.2f atm)",
+                  gas_phase[n].n_user,
+                  use.solution_ptr->n_user,
+                  "reinitializing gas phase with pressure of solution",
+                  (double)gas_phase[n].total_p);
+               dup_print(token, FALSE);
+            }
+         }
+
 			prep();
-			k_temp(use.solution_ptr->tc);
+         k_temp(use.solution_ptr->tc, use.solution_ptr->patm);
 			set(TRUE);
 			converge = model();
 			converge1 = check_residuals();
@@ -1400,7 +1426,7 @@
 			else
 			{
 				prep();
-				k_temp(use.solution_ptr->tc);
+            k_temp(use.solution_ptr->tc, use.solution_ptr->patm);
 				set(TRUE);
 				converge = model();
 			}
@@ -2133,6 +2159,7 @@
 	solution_ptr->new_def = FALSE;
 	solution_ptr->description = string_duplicate(description_x);
 	solution_ptr->tc = tc_x;
+   solution_ptr->patm = patm_x;
 	solution_ptr->ph = ph_x;
 	solution_ptr->solution_pe = solution_pe_x;
 	solution_ptr->mu = mu_x;
diff -u -b /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/model.c ./model.c
--- /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/model.c	2011-03-18 21:30:17.000000000 +0100
+++ ./model.c	2011-11-10 17:40:58.000000000 +0100
@@ -2449,9 +2449,8 @@
 			}
 		}
 	}
-	if (use.gas_phase_ptr != NULL)
+
 		calc_gas_pressures();
-	if (use.s_s_assemblage_ptr != NULL)
 		calc_s_s_fractions();
 
 	return (OK);
@@ -2512,6 +2511,18 @@
 			gas_comp_ptr->phase->fraction_x = 0;
 		}
 	}
+
+   if (use.gas_phase_ptr->type == VOLUME)
+   {
+      /*
+       * Fixed-volume gas phase reacting with a solution
+       * Change pressure used in logK to pressure of gas phase
+       */
+      patm_x = use.gas_phase_ptr->total_p;
+
+      /* Note: fixed pressure gas phase is handled in set_use */
+   }
+
 	return (OK);
 }
 
@@ -2963,6 +2974,7 @@
 	factor = 1.0;
 	sum_deltas = 0.0;
 	for (i = 0; i < count_unknowns; i++)
+
 	{
 		/* fixes underflow problem on Windows */
 		if (delta[i] > 0)
@@ -4239,6 +4251,9 @@
 
 	tc_x = solution_ptr->tc;
 	tk_x = tc_x + 273.15;
+
+   patm_x = solution_ptr->patm;
+
 /*
  *   H+, e-, H2O
  */
@@ -4687,7 +4702,7 @@
 		}
 	}
 	prep();
-	k_temp(tc_x);
+   k_temp(tc_x, patm_x);
 	if (use.surface_ptr->dl_type == DONNAN_DL)
 	{
 		initial_surface_water();
@@ -4719,7 +4734,7 @@
 		{
 			g_iterations++;
 			prev_aq_x = mass_water_aq_x;
-			k_temp(tc_x);
+         k_temp(tc_x, patm_x);
 			gammas(mu_x);
 			molalities(TRUE);
 			mb_sums();
@@ -4749,7 +4764,7 @@
 				debug_model = TRUE;
 				debug_diffuse_layer = TRUE;
 			}
-			k_temp(tc_x);
+         k_temp(tc_x, patm_x);
 			gammas(mu_x);
 			molalities(TRUE);
 			mb_sums();
Only in .: patchTo2.18.out
Only in .: .patchTo2.18.out.swp
diff -u -b /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/phrqproto.h ./phrqproto.h
--- /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/phrqproto.h	2011-03-30 21:21:36.000000000 +0200
+++ ./phrqproto.h	2011-11-10 17:40:58.000000000 +0100
@@ -143,7 +143,8 @@
 int free_cvode(void);
 
 /* main.c */
-int main(int argc, char *argv[]);
+/*int main(int argc, char *argv[]);*/
+int phreeqc_start ( int argc, char *argv[] );
 
 /* mainsubs.c */
 FILE *file_open(char *query, char *default_name, const char *status,
@@ -218,8 +219,8 @@
 
 /* prep.c */
 int check_same_model(void);
-int k_temp(LDBLE tc);
-LDBLE k_calc(LDBLE * logk, LDBLE tempk);
+int k_temp(LDBLE tc, LDBLE pa);
+LDBLE k_calc(LDBLE * logk, LDBLE tempk, LDBLE presPa);
 int prep(void);
 int reprep(void);
 int rewrite_master_to_secondary(struct master *master_ptr1,
diff -u -b /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/pitzer.c ./pitzer.c
--- /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/pitzer.c	2011-11-07 13:26:02.000000000 +0100
+++ ./pitzer.c	2011-11-10 17:40:58.000000000 +0100
@@ -1512,6 +1512,9 @@
 
 	tc_x = solution_ptr->tc;
 	tk_x = tc_x + 273.15;
+
+   patm_x = solution_ptr->patm;
+
 /*
  *   H+, e-, H2O
  */
diff -u -b /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/prep.c ./prep.c
--- /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/prep.c	2011-03-24 17:28:16.000000000 +0100
+++ ./prep.c	2011-11-10 17:40:58.000000000 +0100
@@ -2695,7 +2695,7 @@
  */
 	build_model();
 	same_model = FALSE;
-	k_temp(tc_x);
+   k_temp(tc_x, patm_x);
 
 	return (OK);
 }
@@ -4965,7 +4965,7 @@
 
 /* ---------------------------------------------------------------------- */
 int CLASS_QUALIFIER
-k_temp(LDBLE tempc)
+k_temp(LDBLE tempc, LDBLE pa) /* pa - pressure in atm */
 /* ---------------------------------------------------------------------- */
 {
 /*
@@ -4974,7 +4974,7 @@
 	int i;
 	LDBLE tempk;
 
-	if (same_model == TRUE && same_temperature == TRUE)
+   if (same_model == TRUE && same_temperature == TRUE && same_pressure == TRUE)
 		return (OK);
 
 	tempk = tempc + 273.15;
@@ -4983,7 +4983,7 @@
  */
 	for (i = 0; i < count_s_x; i++)
 	{
-		s_x[i]->lk = k_calc(s_x[i]->rxn_x->logk, tempk);
+      s_x[i]->lk = k_calc(s_x[i]->rxn_x->logk, tempk, pa * PASCAL_PER_ATM);
 	}
 /*
  *    Calculate log k for all pure phases
@@ -4992,7 +4992,7 @@
 	{
 		if (phases[i]->in == TRUE)
 		{
-			phases[i]->lk = k_calc(phases[i]->rxn_x->logk, tempk);
+         phases[i]->lk = k_calc(phases[i]->rxn_x->logk, tempk, pa * PASCAL_PER_ATM);
 		}
 	}
 /*
@@ -5013,24 +5013,35 @@
 
 /* ---------------------------------------------------------------------- */
 LDBLE CLASS_QUALIFIER
-k_calc(LDBLE * l_logk, LDBLE tempk)
+k_calc(LDBLE * l_logk, LDBLE tempk, LDBLE presPa)
 /* ---------------------------------------------------------------------- */
 {
-/*
- *   Calculates log k at specified temperature
- *
- *   Input:
- *       *logk is pointer to logkt0, deltah, and analytical expression data
- *       tempk is temperature in degrees K.
- *
+   /*
+    *   Calculates log k at specified temperature and pressure
  *   Returns calculated log k.
- */
-	return (l_logk[0]
-			- l_logk[1] * (298.15 -
-						 tempk) / (298.15 * tempk * LOG_10 * R_KJ_DEG_MOL) +
-			l_logk[2] + l_logk[3] * tempk + l_logk[4] / tempk +
-			l_logk[5] * log10(tempk) + l_logk[6] / (tempk * tempk)) +
-			l_logk[7] * tempk * tempk;
+    *
+    *   Note: The molar volume is stored in cm3 so the delta_v term is multiplied 
+    *   by 1E-6 to convert it in SI. Another 1E3 factor is needed to convert the 
+    *   universal gas constant in SI (from kJ/(mol*K) to J/(mol*K).
+    *   These two conversion factors are lumped in the 1E-9 factor used below.
+    */
+
+   /* Molar energy */
+   LDBLE me = tempk * R_KJ_DEG_MOL;
+
+   /* Pressure difference */
+   LDBLE delta_p = presPa - REF_PRES_PASCAL;
+
+   /* Calculate new log k value for this temperature and pressure */
+   return    l_logk[logK_T0] 
+           - l_logk[delta_h] * (298.15 - tempk) / (LOG_10 * me * 298.15)
+           + l_logk[T_A1]
+           + l_logk[T_A2] * tempk
+           + l_logk[T_A3] / tempk
+           + l_logk[T_A4] * log10(tempk)
+           + l_logk[T_A5] / (tempk * tempk)
+           + l_logk[T_A6] * tempk * tempk
+           - l_logk[delta_v] * 1E-9 * delta_p / (LOG_10 * me);
 }
 
 /* ---------------------------------------------------------------------- */
@@ -5044,6 +5055,10 @@
  */
 	last_model.temperature = tc_x;
 /*
+ *   save pressure
+ */
+   last_model.pressure = patm_x;
+/*
  *   mark master species 
  */
 	for (i = 0; i < count_master; i++)
@@ -5214,6 +5229,7 @@
 	{
 		last_model.force_prep = FALSE;
 		same_temperature = FALSE;
+      same_pressure = FALSE;
 		return (FALSE);
 	}
 /*
@@ -5228,6 +5244,17 @@
 		same_temperature = FALSE;
 	}
 /*
+ *   Check pressure
+ */
+   if (fabs(patm_x - last_model.pressure) < 0.01)
+   {
+      same_pressure = TRUE;
+   }
+   else
+   {
+      same_pressure = FALSE;
+   }
+/*
  *   Check master species
  */
 	for (i = 0; i < count_master; i++)
diff -u -b /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/print.c ./print.c
--- /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/print.c	2011-03-18 21:30:17.000000000 +0100
+++ ./print.c	2011-11-10 17:40:58.000000000 +0100
@@ -390,7 +390,7 @@
 /*
  *   Calculate pe, eh
  */
-			pe = -k_calc(trxn.logk, tk_x);
+         pe = -k_calc(trxn.logk, tk_x, patm_x * PASCAL_PER_ATM);
 			for (j = 1; j < count_trxn; j++)
 			{
 				pe -= trxn.token[j].s->la * trxn.token[j].coef;
@@ -1106,7 +1106,7 @@
 
 	output_msg(OUTPUT_MESSAGE, "%s\t\n", rxn_ptr->token[0].s->name);
 	output_msg(OUTPUT_MESSAGE, "\n\tlog k:\n");
-	for (j = 0; j < 8; j++)
+   for (j = 0; j < MAX_LOG_K_INDICES; j++)
 	{
 		output_msg(OUTPUT_MESSAGE, "\t%f", (double) rxn_ptr->logk[j]);
 	}
@@ -1243,7 +1243,7 @@
 			iap += rxn_ptr->coef * rxn_ptr->s->la;
 			/* fprintf(output,"\t%s\t%f\t%f\n", rxn_ptr->s->name, rxn_ptr->coef, rxn_ptr->s->la ); */
 		}
-		lk = k_calc(pe_x[default_pe_x].rxn->logk, tk_x);
+      lk = k_calc(pe_x[default_pe_x].rxn->logk, tk_x, patm_x * PASCAL_PER_ATM);
 		la_eminus = lk + iap;
 		/* fprintf(output,"\t%s\t%f\n", "pe", si ); */
 	}
@@ -1270,7 +1270,7 @@
 /*
  *   Print saturation index
  */
-		lk = k_calc(reaction_ptr->logk, tk_x);
+      lk = k_calc(reaction_ptr->logk, tk_x, patm_x * PASCAL_PER_ATM);
 		iap = 0.0;
 		for (rxn_ptr = reaction_ptr->token + 1; rxn_ptr->s != NULL;
 			 rxn_ptr++)
@@ -1338,7 +1338,7 @@
 		else
 		{
 			phase_ptr = x[j]->phase;
-			lk = k_calc(phase_ptr->rxn->logk, tk_x);
+         lk = k_calc(phase_ptr->rxn->logk, tk_x, patm_x * PASCAL_PER_ATM);
 			for (rxn_ptr = phase_ptr->rxn->token + 1; rxn_ptr->s != NULL;
 				 rxn_ptr++)
 			{
@@ -2158,6 +2158,14 @@
 			   (double) (total_co2 / mass_water_aq_x));
 	output_msg(OUTPUT_MESSAGE, "%45s%7.3f\n", "Temperature (deg C)  = ",
 			   (double) tc_x);
+   
+   if (patm_x != 1.0)
+   {
+      /* only print if different than default */
+      output_msg(OUTPUT_MESSAGE, "%45s%7.3f\n", "Pressure (atm)  = ",
+               (double) patm_x);
+   }
+
 	output_msg(OUTPUT_MESSAGE, "%45s%11.3e\n", "Electrical balance (eq)  = ",
 			   (double) cb_x);
 	output_msg(OUTPUT_MESSAGE, "%45s%6.2f\n",
@@ -2827,6 +2835,7 @@
 			fpunchf(PHAST_NULL("dist_x"), dformat, -99);
 		}
 	}
+   /*
 	//if (punch.time == TRUE)
 	//{
 	//	if (state == REACTION && incremental_reactions == TRUE
@@ -2863,7 +2872,7 @@
 	//			}
 	//		}
 	//	}
-
+   */
 	if (punch.time == TRUE)
 	{
 		double reaction_time = kin_time_x;
diff -u -b /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/read.c ./read.c
--- /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/read.c	2011-03-18 21:30:17.000000000 +0100
+++ ./read.c	2011-11-10 17:40:58.000000000 +0100
@@ -52,6 +52,8 @@
 	STATIC int read_debug(void);
 	STATIC int read_delta_h_only(char *ptr, LDBLE * delta_h,
 								 DELTA_H_UNIT * units);
+   STATIC int read_delta_v_only(char *ptr, LDBLE * delta_v,
+                         DELTA_V_UNIT * units);
 	STATIC int read_llnl_aqueous_model_parameters(void);
 	STATIC int read_exchange(void);
 	STATIC int read_exchange_master_species(void);
@@ -882,9 +884,11 @@
 		"llnl_gamma",			/* 15 */
 		"add_logk",				/* 16 */
 		"add_log_k",			/* 17 */
-		"add_constant"			/* 18 */
+      "add_constant",         /* 18 */
+      "delta_v",            /* 19 */   
+      "deltav"            /* 20 */
 	};
-	int count_opt_list = 19;
+   int count_opt_list = 21;
 
 	association = TRUE;
 	s_ptr = NULL;
@@ -1007,7 +1011,7 @@
 				input_error++;
 				break;
 			}
-			read_analytical_expression_only(next_char, &(s_ptr->logk[2]));
+         read_analytical_expression_only(next_char, &(s_ptr->logk[T_A1]));
 			opt_save = OPTION_DEFAULT;
 			break;
 		case 12:				/* gamma */
@@ -1191,6 +1195,22 @@
 			s_ptr->count_add_logk++;
 			opt_save = OPTION_DEFAULT;
 			break;
+      case 19:            /* delta_v */
+      case 20:            /* deltav */
+         if (s_ptr == NULL)
+         {
+            sprintf(error_string,
+                  "No reaction defined before option, %s.",
+                  opt_list[opt]);
+            error_msg(error_string, CONTINUE);
+            input_error++;
+            break;
+         }
+         read_delta_v_only(next_char, &s_ptr->logk[delta_v],
+                       &s_ptr->original_deltav_units);
+         opt_save = OPTION_DEFAULT;
+         break;
+
 		case OPTION_DEFAULT:
 /*
  *   Get exchange species information and parse equation
@@ -3357,14 +3377,78 @@
 
 /* ---------------------------------------------------------------------- */
 int CLASS_QUALIFIER
+read_delta_v_only(char *ptr, LDBLE * delta_v, DELTA_V_UNIT * units)
+/* ---------------------------------------------------------------------- */
+{
+   int j, l;
+   char token[MAX_LENGTH];
+/*
+ *   Read delta V
+ */
+   *delta_v = 0.0;
+   replace("=", " ", ptr);
+   j = copy_token(token, &ptr, &l);
+   if (j == EMPTY)
+   {
+      input_error++;
+      error_msg("Expecting numeric value for delta V.", CONTINUE);
+      return (ERROR);
+   }
+   if (sscanf(token, SCANFORMAT, delta_v) < 1)
+   {
+      input_error++;
+      error_msg("Expecting numeric value for delta V.", CONTINUE);
+      return (ERROR);
+   }
+/*
+ *   Set delta V units (only cm3_per_mole supported for now)
+ */
+
+/*
+ *   Read delta V units
+ */
+   *units = cm3_per_mol;
+
+   j = copy_token(token, &ptr, &l);
+
+   if (j == EMPTY)
+   {
+      return (OK);
+   }
+   if (j == UPPER || j == LOWER)
+   {
+      str_tolower(token);
+      if (strstr(token, "cm3") != NULL)
+      {
+         /* cm3/mol */
+         ;
+      }
+      else if (strstr(token, "dm3") != NULL)
+      {
+         /* Convert dm3/mol to cm3/mol */
+         *delta_v *= 1E3;
+      }
+      else if (strstr(token, "m3") != NULL)
+      {
+         /* Convert m3/mol to cm3/mol */
+         *delta_v *= 1E6;
+      }
+   }
+
+   return (OK);
+}
+
+/* ---------------------------------------------------------------------- */
+int CLASS_QUALIFIER
 read_analytical_expression_only(char *ptr, LDBLE * log_k)
 /* ---------------------------------------------------------------------- */
 {
 	int j;
+   int num_terms = T_A6 - T_A1 + 1;
 /*
  *   Read analytical expression
  */
-	for (j = 0; j < 6; j++)
+   for (j = 0; j < num_terms; j++)
 	{
 		log_k[j] = 0.0;
 	}
@@ -3867,9 +3951,11 @@
 		"ae",					/* 8 */
 		"add_logk",				/* 9 */
 		"add_log_k",			/* 10 */
-		"add_constant"			/* 11 */
+      "add_constant",         /* 11 */
+      "delta_v",            /* 12 */
+      "deltav"            /* 13 */
 	};
-	int count_opt_list = 12;
+   int count_opt_list = 14;
 
 	association = FALSE;
 /*
@@ -3928,7 +4014,7 @@
 		case 8:				/* ae */
 			if (phase_ptr == NULL)
 				break;
-			read_analytical_expression_only(next_char, &(phase_ptr->logk[2]));
+         read_analytical_expression_only(next_char, &(phase_ptr->logk[T_A1]));
 			opt_save = OPTION_DEFAULT;
 			break;
 		case 9:				/* add_logk */
@@ -4020,6 +4106,14 @@
 			phase_ptr->count_add_logk++;
 			opt_save = OPTION_DEFAULT;
 			break;
+      case 12:            /* delta_v */
+      case 13:            /* deltav */
+         if (phase_ptr == NULL)
+            break;
+         read_delta_v_only(next_char, &phase_ptr->logk[delta_v],
+                       &phase_ptr->original_deltav_units);
+         opt_save = OPTION_DEFAULT;
+         break;
 		case OPTION_DEFAULT:
 /*
  *   Get element name and save pointer to character string
@@ -5443,9 +5537,11 @@
 		"pe",					/* 7 */
 		"unit",					/* 8 */
 		"isotope",				/* 9 */
-		"water"					/* 10 */
+      "water",               /* 10 */
+      "press",               /* 11 */
+      "pressure",               /* 12 */
 	};
-	int count_opt_list = 11;
+   int count_opt_list = 13;
 /*
  *   Read solution number and description
  */
@@ -5482,6 +5578,7 @@
  */
 	solution[n]->description = description;
 	solution[n]->tc = 25.0;
+   solution[n]->patm = 1;
 	solution[n]->ph = 7.0;
 	solution[n]->density = 1.0;
 	solution[n]->solution_pe = 4.0;
@@ -5673,6 +5770,13 @@
 				solution[n]->mass_water = (LDBLE) dummy;
 			}
 			break;
+      case 11: /* pressure */
+      case 12:
+         if (sscanf(next_char, SCANFORMAT, &(solution[n]->patm)) != 1)
+         {
+            solution[n]->patm = 1;
+         }
+         break;
 		case OPTION_DEFAULT:
 /*
  *   Read concentration
@@ -5794,9 +5898,11 @@
 		"dw",					/* 19 */
 /* VP: Density Start */
 		"erm_ddl",				/* 20 */
-		"millero"				/* 21 */
+      "millero",            /* 21 */
+      "delta_v",            /* 22 */
+      "deltav"            /* 23 */
 	};
-	int count_opt_list = 22;
+   int count_opt_list = 24;
 /* VP: Density End */
 
 	association = TRUE;
@@ -5941,7 +6047,7 @@
 				input_error++;
 				break;
 			}
-			read_analytical_expression_only(next_char, &(s_ptr->logk[2]));
+         read_analytical_expression_only(next_char, &(s_ptr->logk[T_A1]));
 			opt_save = OPTION_DEFAULT;
 			break;
 		case 13:				/* llnl_gamma */
@@ -6141,6 +6247,21 @@
 			break;
 /* VP: Density End */
 
+      case 22:            /* delta_v */
+      case 23:            /* deltav */
+         if (s_ptr == NULL)
+         {
+            sprintf(error_string,
+                  "No reaction defined before option, %s.",
+                  opt_list[opt]);
+            error_msg(error_string, CONTINUE);
+            input_error++;
+            break;
+         }
+         read_delta_v_only(next_char, &s_ptr->logk[delta_v],
+                       &s_ptr->original_deltav_units);
+         opt_save = OPTION_DEFAULT;
+         break;
 		case OPTION_DEFAULT:
 /*
  *   Get space for species information and parse equation
@@ -6523,9 +6644,11 @@
 		"add_log_k",			/* 14 */
 		"add_constant",			/* 15 */
 		"cd_music",				/* 16 */
-		"music"					/* 17 */
+      "music",            /* 17 */
+      "delta_v",            /* 18 */
+      "deltav"            /* 19 */
 	};
-	int count_opt_list = 18;
+   int count_opt_list = 20;
 
 	association = TRUE;
 	/*
@@ -6648,7 +6771,7 @@
 				input_error++;
 				break;
 			}
-			read_analytical_expression_only(next_char, &(s_ptr->logk[2]));
+         read_analytical_expression_only(next_char, &(s_ptr->logk[T_A1]));
 			opt_save = OPTION_DEFAULT;
 			break;
 		case 12:				/* offset */
@@ -6797,6 +6920,21 @@
 			}
 			opt_save = OPTION_DEFAULT;
 			break;
+      case 18:            /* delta_v */
+      case 19:            /* deltav */
+         if (s_ptr == NULL)
+         {
+            sprintf(error_string,
+                  "No reaction defined before option, %s.",
+                  opt_list[opt]);
+            error_msg(error_string, CONTINUE);
+            input_error++;
+            break;
+         }
+         read_delta_v_only(next_char, &s_ptr->logk[delta_v],
+                       &s_ptr->original_deltav_units);
+         opt_save = OPTION_DEFAULT;
+         break;
 		case OPTION_DEFAULT:
 			/*
 			 *   Get surface species information and parse equation
@@ -7735,7 +7873,7 @@
 				/*
 				 *   Define reaction for psi
 				 */
-				for (i = 0; i < 8; i++)
+            for (i = 0; i < MAX_LOG_K_INDICES; i++)
 				{
 					master[count_master]->s->rxn->logk[i] = 0.0;
 				}
@@ -7810,7 +7948,7 @@
 			/*
 			 *   Define reaction for psi
 			 */
-			for (i = 0; i < 8; i++)
+         for (i = 0; i < MAX_LOG_K_INDICES; i++)
 			{
 				master[count_master]->s->rxn->logk[i] = 0.0;
 			}
@@ -7946,7 +8084,7 @@
 /*
  *   Define reaction for psi
  */
-			for (i = 0; i < 8; i++)
+         for (i = 0; i < MAX_LOG_K_INDICES; i++)
 			{
 				master[count_master]->s->rxn->logk[i] = 0.0;
 			}
@@ -10717,9 +10855,11 @@
 		"ae",					/* 6 */
 		"ln_alpha1000",			/* 7 */
 		"add_logk",				/* 8 */
-		"add_log_k"				/* 9 */
+      "add_log_k",         /* 9 */
+      "delta_v",            /* 10 */
+      "deltav"            /* 11 */
 	};
-	int count_opt_list = 10;
+   int count_opt_list = 12;
 	logk_ptr = NULL;
 /*
  *   Read name followed by options
@@ -10789,7 +10929,7 @@
 				input_error++;
 				break;
 			}
-			read_analytical_expression_only(next_char, &(logk_ptr->log_k[2]));
+         read_analytical_expression_only(next_char, &(logk_ptr->log_k[T_A1]));
 			logk_copy2orig(logk_ptr);
 			opt_save = OPTION_DEFAULT;
 			break;
@@ -10804,7 +10944,7 @@
 				break;
 			}
 			empty = TRUE;
-			for (i = 2; i < 8; i++)
+         for (i = T_A1; i <= T_A6; i++)
 			{
 				if (logk_ptr->log_k[i] != 0.0)
 				{
@@ -10819,8 +10959,8 @@
 						logk_ptr->name);
 				warning_msg(error_string);
 			}
-			read_analytical_expression_only(next_char, &(logk_ptr->log_k[2]));
-			for (i = 2; i < 8; i++)
+         read_analytical_expression_only(next_char, &(logk_ptr->log_k[T_A1]));
+         for (i = T_A1; i < T_A6; i++)
 			{
 				logk_ptr->log_k[i] /= 1000. * LOG_10;
 			}
@@ -10881,6 +11021,22 @@
 			logk_ptr->count_add_logk++;
 			opt_save = OPTION_DEFAULT;
 			break;
+      case 10:            /* delta_v */
+      case 11:            /* deltav */
+         if (logk_ptr == NULL)
+         {
+            sprintf(error_string,
+                  "No reaction defined before option, %s.",
+                  opt_list[opt]);
+            error_msg(error_string, CONTINUE);
+            input_error++;
+            break;
+         }
+         read_delta_v_only(next_char, &logk_ptr->log_k[delta_v],
+                       &logk_ptr->original_deltav_units);
+         logk_copy2orig(logk_ptr);
+         opt_save = OPTION_DEFAULT;
+         break;
 		case OPTION_DEFAULT:
 /*
  *   Get space for logk information
diff -u -b /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/sit.c ./sit.c
--- /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/sit.c	2010-10-25 17:09:04.000000000 +0200
+++ ./sit.c	2011-11-10 17:40:58.000000000 +0100
@@ -546,9 +546,9 @@
 /*
  *   Set master species activities
  */
-
 	tc_x = solution_ptr->tc;
 	tk_x = tc_x + 273.15;
+   patm_x = solution_ptr->patm;
 /*
  *   H+, e-, H2O
  */
diff -u -b /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/spread.c ./spread.c
--- /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/spread.c	2010-07-21 17:56:15.000000000 +0200
+++ ./spread.c	2011-11-10 17:40:58.000000000 +0100
@@ -81,9 +81,10 @@
 		"water",				/* 10 */
 		"isotope_uncertainty",	/* 11 */
 		"uncertainty",			/* 12 */
-		"uncertainties"			/* 13 */
+      "uncertainties",         /* 13 */
+	  "pressure"           /* 14 */
 	};
-	int count_opt_list = 14;
+   int count_opt_list = 15;
 	/*
 	if (svnid == NULL)
 		fprintf(stderr, " ");
@@ -98,6 +99,7 @@
 	soln_defaults.ph = 7.0;
 	soln_defaults.pe = 4.0;
 	soln_defaults.water = 1.0;
+   soln_defaults.pressure = 1.0;
 
 	/* fill in soln_defaults.iso */
 	soln_defaults.count_iso = count_iso_defaults;
@@ -242,6 +244,9 @@
 						opt = opt;
 					}
 					break;
+            case 14: /* pressure */
+               sscanf(next_char, SCANFORMAT, &(soln_defaults.pressure));
+               break;
 				}
 			}
 			spread_row_free(row_ptr);
@@ -501,6 +506,9 @@
 				}
 			}
 			break;
+      case 14: /* pressure */
+         sscanf(next_char, SCANFORMAT, &(soln_defaults.pressure));
+         break;
 		case 100:				/* read headings */
 			heading = string_to_spread_row(line);
 			for (i = 0; i < heading->count; i++)
@@ -643,6 +651,7 @@
  */
 	solution[n]->description = description;
 	solution[n]->tc = defaults.temp;
+   solution[n]->patm = defaults.pressure;
 	solution[n]->ph = defaults.ph;
 	solution[n]->density = defaults.density;
 	solution[n]->solution_pe = defaults.pe;
diff -u -b /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/step.c ./step.c
--- /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/step.c	2009-12-03 01:47:19.000000000 +0100
+++ ./step.c	2011-11-10 17:40:58.000000000 +0100
@@ -237,6 +237,7 @@
 	new_x = FALSE;
 
 	tc_x = 0.0;
+   patm_x = 0;
 	ph_x = 0.0;
 	solution_pe_x = 0.0;
 	mu_x = 0.0;
@@ -290,6 +291,7 @@
  */
 	tc_x += solution_ptr->tc * intensive;
 	ph_x += solution_ptr->ph * intensive;
+   patm_x += solution_ptr->patm * intensive;
 	solution_pe_x += solution_ptr->solution_pe * intensive;
 	mu_x += solution_ptr->mu * intensive;
 	ah2o_x += solution_ptr->ah2o * intensive;
diff -u -b /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/structures.c ./structures.c
--- /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/structures.c	2011-03-31 10:11:57.000000000 +0200
+++ ./structures.c	2011-11-10 17:40:58.000000000 +0100
@@ -3680,7 +3680,7 @@
 	phase_ptr->formula = NULL;
 	phase_ptr->in = FALSE;
 	phase_ptr->lk = 0.0;
-	for (i = 0; i < 8; i++)
+   for (i = 0; i < MAX_LOG_K_INDICES; i++)
 		phase_ptr->logk[i] = 0.0;
 	phase_ptr->original_units = kjoules;
 	phase_ptr->type = SOLID;
@@ -3692,6 +3692,7 @@
 	phase_ptr->rxn_x = NULL;
 	phase_ptr->add_logk = NULL;
 	phase_ptr->count_add_logk = 0;
+   phase_ptr->original_deltav_units = cm3_per_mol;
 	return (OK);
 }
 
@@ -4433,7 +4434,7 @@
 /*
  *   zero log k data
  */
-	for (i = 0; i < 8; i++)
+   for (i = 0; i < MAX_LOG_K_INDICES; i++)
 	{
 		rxn_ptr->logk[i] = 0.0;
 	}
@@ -4484,7 +4485,7 @@
 /*
  *   Copy logk data
  */
-	memcpy(rxn_ptr_new->logk, rxn_ptr_old->logk, (size_t) 8 * sizeof(LDBLE));
+   memcpy(rxn_ptr_new->logk, rxn_ptr_old->logk, (size_t) MAX_LOG_K_INDICES * sizeof(LDBLE));
 /*
  *   Copy dz data
  */
@@ -4563,7 +4564,7 @@
 		return (ERROR);
 	next_token = rxn_ptr->token;
 	output_msg(OUTPUT_MESSAGE, "log k data:\n");
-	for (i = 0; i < 8; i++)
+   for (i = 0; i < MAX_LOG_K_INDICES; i++)
 	{
 		output_msg(OUTPUT_MESSAGE, "\t%f\n", (double) rxn_ptr->logk[i]);
 	}
@@ -4715,7 +4716,7 @@
 	s_ptr->dhb = 0.0;
 	s_ptr->a_f = 0.0;
 	s_ptr->lk = 0.0;
-	for (i = 0; i < 8; i++)
+   for (i = 0; i < MAX_LOG_K_INDICES; i++)
 	{
 		s_ptr->logk[i] = 0.0;
 	}
@@ -4736,6 +4737,7 @@
 	s_ptr->type = 0;
 	s_ptr->gflag = 0;
 	s_ptr->check_equation = TRUE;
+   s_ptr->original_deltav_units = cm3_per_mol;
 
 	for (i = 0; i < 5; i++)
 	{
@@ -5506,6 +5508,7 @@
 	solution_ptr->n_user_end = -1;
 	solution_ptr->description = NULL;
 	solution_ptr->tc = 0;
+   solution_ptr->patm = 0;
 	solution_ptr->ph = 0;
 	solution_ptr->solution_pe = 0;
 	solution_ptr->mu = 0;
@@ -7147,7 +7150,7 @@
 	if (count_trxn == 0)
 	{
 		memcpy((void *) trxn.logk, (void *) r_ptr->logk,
-			   (size_t) 8 * sizeof(LDBLE));
+            (size_t) MAX_LOG_K_INDICES * sizeof(LDBLE));
 		for (i = 0; i < 3; i++)
 		{
 			trxn.dz[i] = r_ptr->dz[i];
@@ -7155,7 +7158,7 @@
 	}
 	else
 	{
-		for (i = 0; i < 8; i++)
+      for (i = 0; i < MAX_LOG_K_INDICES; i++)
 		{
 			trxn.logk[i] += coef * (r_ptr->logk[i]);
 		}
@@ -7213,11 +7216,11 @@
 	if (count_trxn == 0)
 	{
 		memcpy((void *) trxn.logk, (void *) r_ptr->logk,
-			   (size_t) 8 * sizeof(LDBLE));
+            (size_t) MAX_LOG_K_INDICES * sizeof(LDBLE));
 	}
 	else
 	{
-		for (i = 0; i < 8; i++)
+      for (i = 0; i < MAX_LOG_K_INDICES; i++)
 		{
 			trxn.logk[i] += coef * (r_ptr->logk[i]);
 		}
@@ -7373,7 +7376,7 @@
 /*
  *   Copy logk data
  */
-	for (i = 0; i < 8; i++)
+   for (i = 0; i < MAX_LOG_K_INDICES; i++)
 	{
 		rxn_ptr->logk[i] = trxn.logk[i];
 	}
@@ -7440,7 +7443,7 @@
 /*
  *   Multiply log k for reaction
  */
-	for (i = 0; i < 8; i++)
+   for (i = 0; i < MAX_LOG_K_INDICES; i++)
 	{
 		trxn.logk[i] *= coef;
 	}
@@ -7475,7 +7478,7 @@
  */
 
 	output_msg(OUTPUT_MESSAGE, "\tlog k data:\n");
-	for (i = 0; i < 8; i++)
+   for (i = 0; i < MAX_LOG_K_INDICES; i++)
 	{
 		output_msg(OUTPUT_MESSAGE, "\t\t%f\n", (double) trxn.logk[i]);
 	}
@@ -7513,7 +7516,7 @@
 /*
  *   Accumulate log k for reaction
  */
-	for (i = 0; i < 8; i++)
+   for (i = 0; i < MAX_LOG_K_INDICES; i++)
 	{
 		trxn.logk[i] = -trxn.logk[i];
 	}
@@ -7841,7 +7844,7 @@
  *   set varibles = 0
  */
 	logk_ptr->lk = 0.0;
-	for (i = 0; i < 8; i++)
+   for (i = 0; i < MAX_LOG_K_INDICES; i++)
 	{
 		logk_ptr->log_k[i] = 0.0;
 		logk_ptr->log_k_original[i] = 0.0;
@@ -7860,7 +7863,7 @@
  */
 {
 	int i;
-	for (i = 0; i < 8; i++)
+   for (i = 0; i < MAX_LOG_K_INDICES; i++)
 	{
 		logk_ptr->log_k_original[i] = logk_ptr->log_k[i];
 	}
diff -u -b /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/tidy.c ./tidy.c
--- /scratch/nlacr8/Phreeqc/phreeqc-2.18.0/src/tidy.c	2010-09-22 19:17:38.000000000 +0200
+++ ./tidy.c	2011-11-10 17:40:58.000000000 +0100
@@ -601,7 +601,7 @@
 	int j, analytic;
 
 	analytic = FALSE;
-	for (j = 2; j < 8; j++)
+   for (j = T_A1; j <= T_A6; j++)
 	{
 		if (source_k[j] != 0.0)
 		{
@@ -611,22 +611,23 @@
 	}
 	if (analytic == TRUE)
 	{
-		target_k[0] = 0.0;
-		target_k[1] = 0.0;
-		for (j = 2; j < 8; j++)
+      target_k[logK_T0] = 0.0;
+      target_k[delta_h] = 0.0;
+      for (j = T_A1; j <= T_A6; j++)
 		{
 			target_k[j] = source_k[j];
 		}
 	}
 	else
 	{
-		target_k[0] = source_k[0];
-		target_k[1] = source_k[1];
-		for (j = 2; j < 8; j++)
+      target_k[logK_T0] = source_k[logK_T0];
+      target_k[delta_h] = source_k[delta_h];
+      for (j = T_A1; j <= T_A6; j++)
 		{
 			target_k[j] = 0.0;
 		}
 	}
+   target_k[delta_v] = source_k[delta_v];
 	return (OK);
 }
 
@@ -687,7 +688,7 @@
 		}
 		logk_ptr = (struct logk *) found_item->data;
 		analytic = FALSE;
-		for (j = 2; j < 8; j++)
+      for (j = T_A1; j <= T_A6; j++)
 		{
 			if (logk_ptr->log_k[j] != 0.0)
 			{
@@ -697,16 +698,17 @@
 		}
 		if (analytic == TRUE)
 		{
-			for (j = 2; j < 8; j++)
+         for (j = T_A1; j <= T_A6; j++)
 			{
 				source_k[j] += logk_ptr->log_k[j] * coef;
 			}
 		}
 		else
 		{
-			source_k[0] += logk_ptr->log_k[0] * coef;
-			source_k[1] += logk_ptr->log_k[1] * coef;
+         source_k[logK_T0] += logk_ptr->log_k[logK_T0] * coef;
+         source_k[delta_h] += logk_ptr->log_k[delta_h] * coef;
 		}
+      source_k[delta_v] += logk_ptr->log_k[delta_v] * coef;
 	}
 	return (OK);
 }
@@ -759,7 +761,7 @@
 				return (ERROR);
 			}
 		}
-		for (j = 0; j < 8; j++)
+      for (j = 0; j < MAX_LOG_K_INDICES; j++)
 		{
 			logk_ptr->log_k[j] += next_logk_ptr->log_k[j] * coef;
 		}
@@ -1824,6 +1826,7 @@
 						2 * l_a1 * xc * xb2 - 2 * l_a0 * xb * xc2 -
 						8 * l_a1 * xb2 * xc2 + 6 * l_a1 * xb * xc2 + 1;
 					s_s_assemblage[i].s_s[j].comps[1].dnc = dnc / n_tot;
+               
 					s_s_prep(s_s_assemblage[i].s_s[j].tk,
 							 &(s_s_assemblage[i].s_s[j]), TRUE);
 					s_s_assemblage[i].s_s[j].comps[1].dn = 1.0 / n_tot;
@@ -3629,8 +3632,8 @@
 	s_s_ptr->a1 = a1;
 	ag0 = a0 * rt;
 	ag1 = a1 * rt;
-	kc = exp(k_calc(s_s_ptr->comps[0].phase->rxn->logk, t) * LOG_10);
-	kb = exp(k_calc(s_s_ptr->comps[1].phase->rxn->logk, t) * LOG_10);
+   kc = exp(k_calc(s_s_ptr->comps[0].phase->rxn->logk, t, REF_PRES_PASCAL) * LOG_10);
+   kb = exp(k_calc(s_s_ptr->comps[1].phase->rxn->logk, t, REF_PRES_PASCAL) * LOG_10);
 	crit_pt = fabs(a0) + fabs(a1);
 /*
  *   Default, no miscibility or spinodal gaps
@@ -4315,9 +4318,9 @@
 		error_msg(error_string, CONTINUE);
 		return (ERROR);
 	}
-	l_kc = exp(k_calc(s_s_ptr->comps[0].phase->rxn->logk, s_s_ptr->tk) *
+   l_kc = exp(k_calc(s_s_ptr->comps[0].phase->rxn->logk, s_s_ptr->tk, REF_PRES_PASCAL) *
 			 LOG_10);
-	l_kb = exp(k_calc(s_s_ptr->comps[1].phase->rxn->logk, s_s_ptr->tk) *
+   l_kb = exp(k_calc(s_s_ptr->comps[1].phase->rxn->logk, s_s_ptr->tk, REF_PRES_PASCAL) *
 			 LOG_10);
 
 	p = s_s_ptr->p;
